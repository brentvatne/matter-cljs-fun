;; Analyzed by ClojureScript 0.0-2665
{:defs {dissoc-in {:protocol-inline nil, :name plumbing.core/dissoc-in, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 17, :method-params ([m p__24024]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj clj-nil}, :variadic false, :max-fixed-arity 2}), :line 79, :end-line 79, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m [k & ks]])), :doc "Dissociate this keyseq from m, removing any empty maps created as a result\n   (including at the top-level).", :test true}, rsort-by {:doc "Like sort-by, but prefers higher values rather than lower ones.", :file "resources/public/js/compiled/out/plumbing/core.cljs", :line 279, :column 1, :end-line 279, :end-column 15, :test true, :name plumbing.core/rsort-by}, +none+ {:doc "A sentinel value representing missing portions of the input data.", :file "resources/public/js/compiled/out/plumbing/core.cljs", :line 15, :column 1, :end-line 15, :end-column 23, :private true, :test true, :name plumbing.core/+none+}, millis {:protocol-inline nil, :name plumbing.core/millis, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 14, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 0}), :line 362, :end-line 362, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :test true}, swap-pair! {:protocol-inline nil, :name plumbing.core/swap-pair!, :variadic true, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 18, :method-params ([a f] [a f args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 2} {:tag cljs.core/IVector, :variadic true, :max-fixed-arity 2}), :line 345, :end-line 345, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a f] [a f & args])), :doc "Like swap! but returns a pair [old-val new-val]", :test true}, keywordize-map {:protocol-inline nil, :name plumbing.core/keywordize-map, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj cljs.core/LazySeq}, :variadic false, :max-fixed-arity 1}), :line 90, :end-line 90, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Recursively convert maps in m (including itself)\n   to have keyword keys instead of string", :test true}, get-and-set! {:protocol-inline nil, :name plumbing.core/get-and-set!, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 20, :method-params ([a new-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 2}), :line 357, :end-line 357, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a new-val])), :doc "Like reset! but returns old-val", :test true}, positions {:protocol-inline nil, :name plumbing.core/positions, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 17, :method-params ([f s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 197, :end-line 197, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f s])), :doc "Returns indices idx of sequence s where (f (nth s idx))", :test true}, sum {:protocol-inline nil, :name plumbing.core/sum, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 11, :method-params ([f xs] [xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 2} {:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 180, :end-line 180, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f xs] [xs])), :doc "Return sum of (f x) for each x in xs", :test true}, conj-when {:protocol-inline nil, :name plumbing.core/conj-when, :variadic true, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 17, :method-params ([coll x] [coll x xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj}, :variadic false, :max-fixed-arity 2} {:tag #{nil clj}, :variadic true, :max-fixed-arity 2}), :line 264, :end-line 264, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll x] [coll x & xs])), :doc "Like conj but ignores non-truthy values", :test true}, distinct-by {:protocol-inline nil, :name plumbing.core/distinct-by, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 19, :method-params ([f xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 222, :end-line 222, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f xs])), :doc "Returns elements of xs which return unique\n   values according to f. If multiple elements of xs return the same\n   value under f, the first is returned", :test true}, safe-get-in {:protocol-inline nil, :name plumbing.core/safe-get-in, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 19, :method-params ([m ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 119, :end-line 119, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m ks])), :doc "Like get-in but throws exception if not found", :test true}, indexed {:protocol-inline nil, :name plumbing.core/indexed, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 15, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 192, :end-line 192, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Returns [idx x] for x in seqable s", :test true}, cons-when {:protocol-inline nil, :name plumbing.core/cons-when, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 17, :method-params ([x s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/Cons}, :variadic false, :max-fixed-arity 2}), :line 274, :end-line 274, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x s])), :doc "Like cons but does nothing if x is non-truthy.", :test true}, mapply {:protocol-inline nil, :name plumbing.core/mapply, :variadic true, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 14, :method-params ([f m] [f arg args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic true, :max-fixed-arity 2}), :line 366, :end-line 366, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f m] [f arg & args])), :doc "Like apply, but applies a map to a function with positional map\n  arguments. Can take optional initial args just like apply.", :test true}, map-keys {:protocol-inline nil, :name plumbing.core/map-keys, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 16, :method-params ([f m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 62, :end-line 62, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f m])), :doc "Build map (f k) -> v for [k v] in map m", :test true}, interleave-all {:protocol-inline nil, :name plumbing.core/interleave-all, :variadic true, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 22, :method-params ([colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic true, :max-fixed-arity 0}), :line 249, :end-line 249, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& colls])), :doc "Analogy: partition:partition-all :: interleave:interleave-all", :test true}, update {:protocol-inline nil, :name plumbing.core/update, :variadic true, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 14, :method-params ([m k f] [m k f x1] [m k f x1 x2] [m k f x1 x2 xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3} {:tag clj, :variadic false, :max-fixed-arity 4} {:tag clj, :variadic false, :max-fixed-arity 5} {:tag clj, :variadic true, :max-fixed-arity 5}), :line 41, :end-line 41, :max-fixed-arity 5, :fn-var true, :arglists (quote ([m k f] [m k f x1] [m k f x1 x2] [m k f x1 x2 & xs])), :doc "Updates the value in map m at k with the function f.\n\n  Like update-in, but for updating a single top-level key.\n  Any additional args will be passed to f after the value.", :test true}, grouped-map {:protocol-inline nil, :name plumbing.core/grouped-map, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 19, :method-params ([key-fn map-fn coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3}), :line 143, :end-line 143, :max-fixed-arity 3, :fn-var true, :arglists (quote ([key-fn map-fn coll])), :doc "Like group-by, but accepts a map-fn that is applied to values before\n   collected.", :test true}, count-when {:protocol-inline nil, :name plumbing.core/count-when, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 18, :method-params ([pred xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 259, :end-line 259, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred xs])), :doc "Returns # of elements of xs where pred holds", :test true}, aconcat {:protocol-inline nil, :name plumbing.core/aconcat, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 15, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 158, :end-line 158, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Like (apply concat s) but lazier (and shorter) ", :test true}, singleton {:protocol-inline nil, :name plumbing.core/singleton, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 17, :method-params ([xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 185, :end-line 185, :max-fixed-arity 1, :fn-var true, :arglists (quote ([xs])), :doc "returns (first xs) when xs has only 1 element", :test true}, map-from-keys {:protocol-inline nil, :name plumbing.core/map-from-keys, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 21, :method-params ([f ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 69, :end-line 69, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f ks])), :doc "Build map k -> (f k) for keys in ks", :test true}, map-vals {:protocol-inline nil, :name plumbing.core/map-vals, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 16, :method-params ([f m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any}, :variadic false, :max-fixed-arity 2}), :line 51, :end-line 51, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f m])), :doc "Build map k -> (f v) for [k v] in map, preserving the initial type", :test true}, assoc-when {:protocol-inline nil, :name plumbing.core/assoc-when, :variadic true, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 18, :method-params ([m kvs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic true, :max-fixed-arity 1}), :line 126, :end-line 126, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m & kvs])), :doc "Like assoc but only assocs when value is truthy", :test true}, map-from-vals {:protocol-inline nil, :name plumbing.core/map-from-vals, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 21, :method-params ([f vs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 74, :end-line 74, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f vs])), :doc "Build map (f v) -> v for vals in vs", :test true}, update-in-when {:protocol-inline nil, :name plumbing.core/update-in-when, :variadic true, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 22, :method-params ([m key-seq f args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj}, :variadic true, :max-fixed-arity 3}), :line 135, :end-line 135, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m key-seq f & args])), :doc "Like update-in but returns m unchanged if key-seq is not present.", :test true}, unchunk {:protocol-inline nil, :name plumbing.core/unchunk, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 15, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/Cons clj-nil}, :variadic false, :max-fixed-arity 1}), :line 163, :end-line 163, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Takes a seqable and returns a lazy sequence that\n   is maximally lazy and doesn't realize elements due to either\n   chunking or apply.\n\n   Useful when you don't want chunking, for instance,\n   (first awesome-website? (map slurp +a-bunch-of-urls+))\n   may slurp up to 31 unneed webpages, wherease\n   (first awesome-website? (map slurp (unchunk +a-bunch-of-urls+)))\n   is guaranteed to stop slurping after the first awesome website.\n\n  Taken from http://stackoverflow.com/questions/3407876/how-do-i-avoid-clojures-chunking-behavior-for-lazy-seqs-that-i-want-to-short-ci", :test true}, safe-get {:protocol-inline nil, :name plumbing.core/safe-get, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 16, :method-params ([m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 2}), :line 112, :end-line 112, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k])), :doc "Like get but throw an exception if not found", :test true}}, :name plumbing.core, :doc "Utility belt for Clojure in the wild", :excludes #{update}, :use-macros {lazy-get plumbing.core, for-map plumbing.core}, :require-macros {schema plumbing.fnk.schema, plumbing.fnk.schema plumbing.fnk.schema, plumbing.core plumbing.core}, :uses nil, :requires {schema plumbing.fnk.schema, plumbing.fnk.schema plumbing.fnk.schema, schema.utils schema.utils, schema-utils schema.utils}, :imports nil}