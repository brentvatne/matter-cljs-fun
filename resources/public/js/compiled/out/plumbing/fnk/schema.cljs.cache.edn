;; Analyzed by ClojureScript 0.0-2665
{:defs {required-toplevel-keys {:schema (schema.core/make-fn-schema output-schema22851 [input-schema22852]), :protocol-inline nil, :name plumbing.fnk.schema/required-toplevel-keys, :variadic false, :file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :end-column 32, :method-params ([G__22855]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :raw-arglists (quote ([input-schema :- InputSchema])), :line 141, :end-line 141, :max-fixed-arity 1, :fn-var true, :arglists (quote ([input-schema])), :doc "Inputs: [input-schema :- InputSchema]\n  Returns: [s/Keyword]\n\n  Which top-level keys are required (i.e., non-false) by this input schema.", :test true}, InputSchema {:file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :line 23, :column 1, :end-line 23, :end-column 18, :test true, :name plumbing.fnk.schema/InputSchema}, possibly-contains? {:protocol-inline nil, :name plumbing.fnk.schema/possibly-contains?, :variadic false, :file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :end-column 26, :method-params ([m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 2}), :line 217, :end-line 217, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k])), :test true}, schema-key {:protocol-inline nil, :name plumbing.fnk.schema/schema-key, :variadic false, :file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :end-column 18, :method-params ([m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil schema.core/OptionalKey clj-nil}, :variadic false, :max-fixed-arity 2}), :line 208, :end-line 208, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k])), :test true}, map-schema? {:protocol-inline nil, :name plumbing.fnk.schema/map-schema?, :variadic false, :file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :end-column 19, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 74, :end-line 74, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :test true}, MapOutputSchema {:file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :line 28, :column 1, :end-line 28, :end-column 22, :test true, :name plumbing.fnk.schema/MapOutputSchema}, unwrap-schema-form-key {:schema (schema.core/make-fn-schema output-schema22781 [input-schema22782]), :protocol-inline nil, :name plumbing.fnk.schema/unwrap-schema-form-key, :variadic false, :file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :end-column 32, :method-params ([G__22785]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/IVector clj-nil}, :variadic false, :max-fixed-arity 1}), :raw-arglists (quote ([k])), :line 81, :end-line 81, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :doc "Inputs: [k]\n  Returns: (s/maybe (s/pair s/Keyword \"k\" s/Bool \"optional?\"))\n\n  Given a possibly-unevaluated schema map key form, unpack an explicit keyword\n   and optional? flag, or return nil for a non-explicit key", :test true}, non-map-union {:protocol-inline nil, :name plumbing.fnk.schema/non-map-union, :variadic false, :file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :end-column 21, :method-params ([s1 s2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil schema.core/Both}, :variadic false, :max-fixed-arity 2}), :line 62, :end-line 62, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s1 s2])), :test true}, split-schema-keys {:schema (schema.core/make-fn-schema output-schema22811 [input-schema22812]), :protocol-inline nil, :name plumbing.fnk.schema/split-schema-keys, :variadic false, :file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :end-column 27, :method-params ([G__22815]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 1}), :raw-arglists (quote ([s :- {s/Keyword s/Bool}])), :line 102, :end-line 102, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Inputs: [s :- {s/Keyword s/Bool}]\n  Returns: [(s/one [s/Keyword] (quote required)) (s/one [s/Keyword] (quote optional))]\n\n  Given output of explicit-schema-key-map, split into seq [req opt].", :test true}, explicit-schema-key-map {:schema (schema.core/make-fn-schema output-schema22796 [input-schema22797]), :protocol-inline nil, :name plumbing.fnk.schema/explicit-schema-key-map, :variadic false, :file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :end-column 33, :method-params ([G__22800]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 1}), :raw-arglists (quote ([s])), :line 93, :end-line 93, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Inputs: [s]\n  Returns: {s/Keyword s/Bool}\n\n  Given a possibly-unevaluated map schema, return a map from bare keyword to true\n   (for required) or false (for optional)", :test true}, schema-diff {:protocol-inline nil, :name plumbing.fnk.schema/schema-diff, :variadic false, :file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :end-column 19, :method-params ([input-schema output-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil schema.utils/ErrorContainer clj-nil}, :variadic false, :max-fixed-arity 2}), :line 166, :end-line 166, :max-fixed-arity 2, :fn-var true, :arglists (quote ([input-schema output-schema])), :doc "Subtract output-schema from input-schema, returning nil if it's possible that an object\n   satisfying the output-schema satisfies the input-schema, or otherwise a description\n   of the part(s) of input-schema not met by output-schema.  Strict about the map structure\n   of output-schema matching input-schema, but loose about everything else (only looks at\n   required keys of output-schema.", :test true}, non-map-diff {:protocol-inline nil, :name plumbing.fnk.schema/non-map-diff, :variadic false, :file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :end-column 20, :method-params ([s1 s2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 2}), :line 68, :end-line 68, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s1 s2])), :doc "Return a difference of schmas s1 and s2, where one is not a map.\n   Punt for now, assuming s2 always satisfies s1.", :test true}, guess-expr-output-schema {:protocol-inline nil, :name plumbing.fnk.schema/guess-expr-output-schema, :variadic false, :file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :end-column 32, :method-params ([expr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any cljs.core/Symbol cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 1}), :line 155, :end-line 155, :max-fixed-arity 1, :fn-var true, :arglists (quote ([expr])), :doc "Guess an output schema for an expr.  Currently just looks for literal map structure and\n   all keyword keys.", :test true}, compose-schemata {:schema (schema.core/make-fn-schema output-schema22906 [input-schema22907]), :protocol-inline nil, :name plumbing.fnk.schema/compose-schemata, :variadic false, :file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :end-column 44, :method-params ([G__22910 G__22911]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 2}), :raw-arglists (quote ([[i2 o2] :- IOSchemata [i1 o1] :- [(s/one InputSchema (quote input)) (s/one MapOutputSchema (quote output))]])), :line 198, :end-line 198, :max-fixed-arity 2, :fn-var true, :arglists (quote ([[i2 o2] [i1 o1]])), :doc "Inputs: [[i2 o2] :- IOSchemata [i1 o1] :- [(s/one InputSchema (quote input)) (s/one MapOutputSchema (quote output))]]\n\n  Given pairs of input and output schemata for fnks f1 and f2,\n   return a pair of input and output schemata for #(f2 (merge % (f1 %))).\n   f1's output schema must not contain any optional keys.", :test true, :always-validate true}, assert-satisfies-schema {:protocol-inline nil, :name plumbing.fnk.schema/assert-satisfies-schema, :variadic false, :file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :end-column 31, :method-params ([input-schema output-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 2}), :line 194, :end-line 194, :max-fixed-arity 2, :fn-var true, :arglists (quote ([input-schema output-schema])), :test true}, split-schema {:schema (schema.core/make-fn-schema output-schema22938 [input-schema22939]), :protocol-inline nil, :name plumbing.fnk.schema/split-schema, :variadic false, :file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :end-column 22, :method-params ([G__22942 G__22943]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :raw-arglists (quote ([s :- InputSchema ks :- [s/Keyword]])), :line 220, :end-line 220, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s ks])), :doc "Inputs: [s :- InputSchema ks :- [s/Keyword]]\n\n  Return a pair [ks-part non-ks-part], with any extra schema removed.", :test true}, assert-distinct {:protocol-inline nil, :name plumbing.fnk.schema/assert-distinct, :variadic false, :file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :end-column 23, :method-params ([things]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 1}), :line 39, :end-line 39, :max-fixed-arity 1, :fn-var true, :arglists (quote ([things])), :doc "Like (assert (distinct? things)) but with a more helpful error message.", :test true}, OutputSchema {:file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :line 24, :column 1, :end-line 24, :end-column 19, :test true, :name plumbing.fnk.schema/OutputSchema}, GraphInputSchema {:file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :line 27, :column 1, :end-line 27, :end-column 23, :test true, :name plumbing.fnk.schema/GraphInputSchema}, GraphIOSchemata {:file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :line 29, :column 1, :end-line 29, :end-column 22, :test true, :name plumbing.fnk.schema/GraphIOSchemata}, merge-on-with {:protocol-inline nil, :private true, :name plumbing.fnk.schema/merge-on-with, :variadic true, :file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :end-column 22, :method-params ([key-project key-combine val-combine maps]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic true, :max-fixed-arity 3}), :line 109, :end-line 109, :max-fixed-arity 3, :fn-var true, :arglists (quote ([key-project key-combine val-combine & maps])), :doc "Like merge-with, but also projects keys to a smaller space and merges them similar to the\n   values.", :test true}, Schema {:file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :line 22, :column 1, :end-line 22, :end-column 13, :test true, :name plumbing.fnk.schema/Schema}, IOSchemata {:file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :line 25, :column 1, :end-line 25, :end-column 17, :test true, :name plumbing.fnk.schema/IOSchemata}, union-input-schemata {:schema (schema.core/make-fn-schema output-schema22835 [input-schema22836]), :protocol-inline nil, :name plumbing.fnk.schema/union-input-schemata, :variadic false, :file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :end-column 30, :method-params ([G__22839 G__22840]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2}), :raw-arglists (quote ([i1 :- InputSchema i2 :- InputSchema])), :line 124, :end-line 124, :max-fixed-arity 2, :fn-var true, :arglists (quote ([i1 i2])), :doc "Inputs: [i1 :- InputSchema i2 :- InputSchema]\n  Returns: InputSchema\n\n  Returns a minimal input schema schema that entails satisfaction of both s1 and s2", :test true}, sequence-schemata {:schema (schema.core/make-fn-schema output-schema23033 [input-schema23034]), :protocol-inline nil, :name plumbing.fnk.schema/sequence-schemata, :variadic false, :file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :end-column 27, :method-params ([G__23037 G__23038]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 2}), :raw-arglists (quote ([[i1 o1] :- GraphIOSchemata [k [i2 o2]] :- [(s/one s/Keyword "key") (s/one IOSchemata "inner-schemas")]])), :line 230, :end-line 230, :max-fixed-arity 2, :fn-var true, :arglists (quote ([[i1 o1] [k [i2 o2]]])), :doc "Inputs: [[i1 o1] :- GraphIOSchemata [k [i2 o2]] :- [(s/one s/Keyword \"key\") (s/one IOSchemata \"inner-schemas\")]]\n  Returns: GraphIOSchemata\n\n  Given pairs of input and output schemata for fnks f1 and f2, and a keyword k,\n   return a pair of input and output schemata for #(let [v1 (f1 %)] (assoc v1 k (f2 (merge-disjoint % v1))))", :test true}, safe-get {:protocol-inline nil, :name plumbing.fnk.schema/safe-get, :variadic false, :file "resources/public/js/compiled/out/plumbing/fnk/schema.cljs", :end-column 16, :method-params ([m k key-path]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any clj-nil}, :variadic false, :max-fixed-arity 3}), :line 48, :end-line 48, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k key-path])), :doc "Like (get m k), but throws if k is not present in m.", :test true}}, :name plumbing.fnk.schema, :doc "A very simple type system for a subset of schemas consisting of nested\n   maps with optional or required keyword keys; used by fnk and kin.\n\n   Since schemas are turing-complete and not really designed for type inference,\n   (and for simplicity) we err on the side of completeness (allowing all legal programs)\n   at the cost of soundness.\n\n   These operations also bake in some logic specific to reasoning about Graphs,\n   namely that all input keys to a node must be explicitly mentioned as optional or\n   required, or provided via `instance`, and will thus deliberately drop extra key\n   schemas on inputs as appropriate.  Output schemas may not have optional keys.", :excludes #{}, :use-macros {assert-iae plumbing.fnk.schema}, :require-macros {s schema.core, schema.core schema.core, plumbing.fnk.schema plumbing.fnk.schema, schema.macros schema.macros, schema-macros schema.macros}, :uses nil, :requires {schema-utils schema.utils, schema.utils schema.utils, schema.core schema.core, s schema.core}, :imports nil}