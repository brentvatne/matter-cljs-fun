;; Analyzed by ClojureScript 0.0-2665
{:defs {->Predicate {:protocol-inline nil, :name schema.core/->Predicate, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 35, :method-params ([p? pred-name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :methods ({:tag schema.core/Predicate, :variadic false, :max-fixed-arity 2}), :line 302, :end-line 302, :max-fixed-arity 2, :fn-var true, :arglists (quote ([p? pred-name])), :test true}, ConditionalSchema {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/ConditionalSchema, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 43, :type true, :column 25, :internal-ctor true, :line 501, :record true, :end-line 501, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, arity {:protocol-inline nil, :private true, :name schema.core/arity, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 27, :method-params ([input-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil number}, :variadic false, :max-fixed-arity 1}), :line 916, :end-line 916, :max-fixed-arity 1, :fn-var true, :arglists (quote ([input-schema])), :test true}, map->FnSchema {:protocol-inline nil, :name schema.core/map->FnSchema, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 34, :method-params ([G__23864]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :methods ({:tag schema.core/FnSchema, :variadic false, :max-fixed-arity 1}), :line 904, :end-line 904, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__23864])), :test true}, ->One {:protocol-inline nil, :name schema.core/->One, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 29, :method-params ([schema optional? name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :methods ({:tag schema.core/One, :variadic false, :max-fixed-arity 3}), :line 777, :end-line 777, :max-fixed-arity 3, :fn-var true, :arglists (quote ([schema optional? name])), :test true}, named {:protocol-inline nil, :name schema.core/named, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 26, :method-params ([schema name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag schema.core/NamedSchema, :variadic false, :max-fixed-arity 2}), :line 444, :end-line 444, :max-fixed-arity 2, :fn-var true, :arglists (quote ([schema name])), :doc "A value that must satisfy schema, and has a name for documentation purposes.", :test true}, optional-key {:protocol-inline nil, :name schema.core/optional-key, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 33, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag schema.core/OptionalKey, :variadic false, :max-fixed-arity 1}), :line 610, :end-line 610, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :doc "An optional key in a map", :test true}, Protocol {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/Protocol, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 34, :type true, :column 25, :internal-ctor true, :line 334, :record true, :end-line 334, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, map->AnythingSchema {:protocol-inline nil, :name schema.core/map->AnythingSchema, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 40, :method-params ([G__23616]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :methods ({:tag schema.core/AnythingSchema, :variadic false, :max-fixed-arity 1}), :line 234, :end-line 234, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__23616])), :test true}, map-explain {:protocol-inline nil, :private true, :name schema.core/map-explain, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 33, :method-params ([this]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 1}), :line 734, :end-line 734, :max-fixed-arity 1, :fn-var true, :arglists (quote ([this])), :test true}, Maybe {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/Maybe, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 31, :type true, :column 25, :internal-ctor true, :line 420, :record true, :end-line 420, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, MapEntry {:num-fields 2, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/MapEntry, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 34, :type true, :column 25, :internal-ctor true, :line 640, :record true, :end-line 640, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, One {:num-fields 3, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/One, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 29, :type true, :column 25, :internal-ctor true, :line 777, :record true, :end-line 777, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, ->Isa {:protocol-inline nil, :name schema.core/->Isa, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 29, :method-params ([h parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :methods ({:tag schema.core/Isa, :variadic false, :max-fixed-arity 2}), :line 264, :end-line 264, :max-fixed-arity 2, :fn-var true, :arglists (quote ([h parent])), :test true}, map->ConditionalSchema {:protocol-inline nil, :name schema.core/map->ConditionalSchema, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 43, :method-params ([G__23704]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :methods ({:tag schema.core/ConditionalSchema, :variadic false, :max-fixed-arity 1}), :line 501, :end-line 501, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__23704])), :test true}, NamedSchema {:num-fields 2, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/NamedSchema, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 37, :type true, :column 25, :internal-ctor true, :line 437, :record true, :end-line 437, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, map->MapEntry {:protocol-inline nil, :name schema.core/map->MapEntry, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 34, :method-params ([G__23754]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :methods ({:tag schema.core/MapEntry, :variadic false, :max-fixed-arity 1}), :line 640, :end-line 640, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__23754])), :test true}, required-key? {:protocol-inline nil, :name schema.core/required-key?, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 34, :method-params ([ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 604, :end-line 604, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ks])), :test true}, ->Both {:protocol-inline nil, :name schema.core/->Both, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 30, :method-params ([schemas]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :methods ({:tag schema.core/Both, :variadic false, :max-fixed-arity 1}), :line 476, :end-line 476, :max-fixed-arity 1, :fn-var true, :arglists (quote ([schemas])), :test true}, schema-with-name {:protocol-inline nil, :name schema.core/schema-with-name, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 37, :method-params ([schema name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2}), :line 955, :end-line 955, :max-fixed-arity 2, :fn-var true, :arglists (quote ([schema name])), :test true}, Symbol {:doc "A symbol", :file "resources/public/js/compiled/out/schema/core.cljs", :line 397, :column 1, :end-line 397, :end-column 13, :test true, :name schema.core/Symbol}, Either {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/Either, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 32, :type true, :column 25, :internal-ctor true, :line 452, :record true, :end-line 452, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, map->One {:protocol-inline nil, :name schema.core/map->One, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 29, :method-params ([G__23812]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :methods ({:tag schema.core/One, :variadic false, :max-fixed-arity 1}), :line 777, :end-line 777, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__23812])), :test true}, fn-schema {:protocol-inline nil, :name schema.core/fn-schema, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 40, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 1045, :ret-tag FnSchema, :end-line 1045, :max-fixed-arity 1, :tag FnSchema, :fn-var true, :arglists (quote ([f])), :doc "Produce the schema for a function defined with s/fn or s/defn.", :test true}, conditional {:protocol-inline nil, :name schema.core/conditional, :variadic true, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 32, :method-params ([preds-and-schemas]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag schema.core/ConditionalSchema, :variadic true, :max-fixed-arity 0}), :line 515, :end-line 515, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& preds-and-schemas])), :doc "Define a conditional schema.  Takes args like cond,\n   (conditional pred1 schema1 pred2 schema2 ...),\n   and checks the first schema where pred is true on the value.\n   Unlike cond, throws if the value does not match any condition.\n   :else may be used as a final condition in the place of (constantly true).\n   More efficient than either, since only one schema must be checked.", :test true}, either {:protocol-inline nil, :name schema.core/either, :variadic true, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 27, :method-params ([schemas]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag schema.core/Either, :variadic true, :max-fixed-arity 0}), :line 468, :end-line 468, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& schemas])), :doc "A value that must satisfy at least one schema in schemas.", :test true}, explicit-schema-key {:protocol-inline nil, :name schema.core/explicit-schema-key, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 40, :method-params ([ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil any}, :variadic false, :max-fixed-arity 1}), :line 619, :end-line 619, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ks])), :test true}, schema-name {:protocol-inline nil, :name schema.core/schema-name, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 32, :method-params ([schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 959, :end-line 959, :max-fixed-arity 1, :fn-var true, :arglists (quote ([schema])), :test true}, Bool {:doc "Boolean true or false", :file "resources/public/js/compiled/out/schema/core.cljs", :line 381, :column 1, :end-line 381, :end-column 11, :test true, :name schema.core/Bool}, ->EqSchema {:protocol-inline nil, :name schema.core/->EqSchema, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 34, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :methods ({:tag schema.core/EqSchema, :variadic false, :max-fixed-arity 1}), :line 248, :end-line 248, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :test true}, enum {:protocol-inline nil, :name schema.core/enum, :variadic true, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 25, :method-params ([vs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag schema.core/EnumSchema, :variadic true, :max-fixed-arity 0}), :line 294, :end-line 294, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& vs])), :doc "A value that must be = to some element of vs.", :test true}, one {:protocol-inline nil, :name schema.core/one, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 24, :method-params ([schema name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag schema.core/One, :variadic false, :max-fixed-arity 2}), :line 779, :end-line 779, :max-fixed-arity 2, :fn-var true, :arglists (quote ([schema name])), :doc "A single required element of a sequence (not repeated, the implicit default)", :test true}, find-extra-keys-schema {:protocol-inline nil, :name schema.core/find-extra-keys-schema, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 43, :method-params ([map-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 685, :end-line 685, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-schema])), :test true}, map->Predicate {:protocol-inline nil, :name schema.core/map->Predicate, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 35, :method-params ([G__23650]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :methods ({:tag schema.core/Predicate, :variadic false, :max-fixed-arity 1}), :line 302, :end-line 302, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__23650])), :test true}, map->RequiredKey {:protocol-inline nil, :name schema.core/map->RequiredKey, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 37, :method-params ([G__23738]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :methods ({:tag schema.core/RequiredKey, :variadic false, :max-fixed-arity 1}), :line 595, :end-line 595, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__23738])), :test true}, Record {:num-fields 2, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/Record, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 32, :type true, :column 25, :internal-ctor true, :line 862, :record true, :end-line 862, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, parse-sequence-schema {:protocol-inline nil, :name schema.core/parse-sequence-schema, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 42, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 1}), :line 789, :end-line 789, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :test true}, OptionalKey {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/OptionalKey, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 37, :type true, :column 25, :internal-ctor true, :line 608, :record true, :end-line 608, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, map->Record {:protocol-inline nil, :name schema.core/map->Record, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 32, :method-params ([G__23852]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :methods ({:tag schema.core/Record, :variadic false, :max-fixed-arity 1}), :line 862, :end-line 862, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__23852])), :test true}, EqSchema {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/EqSchema, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 34, :type true, :column 25, :internal-ctor true, :line 248, :record true, :end-line 248, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, explain {:protocol-inline nil, :protocol schema.core/Schema, :name schema.core/explain, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 12, :method-params ([this]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 95, :end-line 112, :max-fixed-arity 1, :fn-var true, :arglists (quote ([this])), :test true}, ->RequiredKey {:protocol-inline nil, :name schema.core/->RequiredKey, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 37, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :methods ({:tag schema.core/RequiredKey, :variadic false, :max-fixed-arity 1}), :line 595, :end-line 595, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :test true}, subschema-walker {:protocol-inline nil, :name schema.core/subschema-walker, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 33, :method-params ([s]), :protocol-impl nil, :arglists-meta (), :column 1, :methods ({:tag ignore, :variadic false, :max-fixed-arity 1}), :dynamic true, :line 127, :end-line 127, :max-fixed-arity 1, :fn-var true, :arglists nil, :doc "The function to call within 'walker' implementations to create walkers for subschemas.\n   Can be dynamically bound (using start-walker below) to create different walking behaviors.\n\n   For the curious, implemented using dynamic binding rather than making walker take a\n   subschema-walker as an argument because some behaviors (e.g. recursive schema walkers)\n   seem to require mind-bending things like fixed-point combinators that way, but are\n   simple this way.", :test true}, map->Protocol {:protocol-inline nil, :name schema.core/map->Protocol, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 34, :method-params ([G__23659]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :methods ({:tag schema.core/Protocol, :variadic false, :max-fixed-arity 1}), :line 334, :end-line 334, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__23659])), :test true}, preserve-map-type {:protocol-inline nil, :private true, :name schema.core/preserve-map-type, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 39, :method-params ([original walker-result]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2}), :line 692, :end-line 692, :max-fixed-arity 2, :fn-var true, :arglists (quote ([original walker-result])), :test true}, fn-validation? {:protocol-inline nil, :name schema.core/fn-validation?, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 35, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 0}), :line 1014, :end-line 1014, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Get the current global schema validation setting.", :test true}, isa {:protocol-inline nil, :name schema.core/isa, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 24, :method-params ([parent] [h parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag schema.core/Isa, :variadic false, :max-fixed-arity 1} {:tag schema.core/Isa, :variadic false, :max-fixed-arity 2}), :line 275, :end-line 275, :max-fixed-arity 2, :fn-var true, :arglists (quote ([parent] [h parent])), :doc "A value that must be a child of parent.", :test true}, Num {:doc "Any number", :file "resources/public/js/compiled/out/schema/core.cljs", :line 385, :column 1, :end-line 385, :end-column 10, :test true, :name schema.core/Num}, eq {:protocol-inline nil, :name schema.core/eq, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 23, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag schema.core/EqSchema, :variadic false, :max-fixed-arity 1}), :line 257, :end-line 257, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "A value that must be (= v).", :test true}, validate {:protocol-inline nil, :name schema.core/validate, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 29, :method-params ([schema value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 162, :end-line 162, :max-fixed-arity 2, :fn-var true, :arglists (quote ([schema value])), :doc "Throw an exception if value does not satisfy schema; otherwise, return value.", :test true}, pred {:protocol-inline nil, :name schema.core/pred, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 25, :method-params ([p?] [p? pred-name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag schema.core/Predicate, :variadic false, :max-fixed-arity 1} {:tag schema.core/Predicate, :variadic false, :max-fixed-arity 2}), :line 316, :end-line 316, :max-fixed-arity 2, :fn-var true, :arglists (quote ([p?] [p? pred-name])), :doc "A value for which p? returns true (and does not throw).\n   Optional pred-name can be passed for nicer validation errors.", :test true}, AnythingSchema {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/AnythingSchema, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 40, :type true, :column 25, :internal-ctor true, :line 234, :record true, :end-line 234, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, Any {:doc "Any value, including nil.", :file "resources/public/js/compiled/out/schema/core.cljs", :line 242, :column 1, :end-line 242, :end-column 10, :test true, :name schema.core/Any}, Regex {:doc "A regular expression", :file "resources/public/js/compiled/out/schema/core.cljs", :line 401, :column 1, :end-line 401, :end-column 12, :test true, :name schema.core/Regex}, ->EnumSchema {:protocol-inline nil, :name schema.core/->EnumSchema, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 36, :method-params ([vs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :methods ({:tag schema.core/EnumSchema, :variadic false, :max-fixed-arity 1}), :line 285, :end-line 285, :max-fixed-arity 1, :fn-var true, :arglists (quote ([vs])), :test true}, RequiredKey {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/RequiredKey, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 37, :type true, :column 25, :internal-ctor true, :line 595, :record true, :end-line 595, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, explain-kspec {:protocol-inline nil, :private true, :name schema.core/explain-kspec, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 35, :method-params ([kspec]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any}, :variadic false, :max-fixed-arity 1}), :line 629, :end-line 629, :max-fixed-arity 1, :fn-var true, :arglists (quote ([kspec])), :test true}, Inst {:doc "The local representation of #inst ...", :file "resources/public/js/compiled/out/schema/core.cljs", :line 405, :column 1, :end-line 405, :end-column 11, :test true, :name schema.core/Inst}, map->OptionalKey {:protocol-inline nil, :name schema.core/map->OptionalKey, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 37, :method-params ([G__23746]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :methods ({:tag schema.core/OptionalKey, :variadic false, :max-fixed-arity 1}), :line 608, :end-line 608, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__23746])), :test true}, FnSchema {:num-fields 2, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/FnSchema, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 34, :type true, :column 25, :internal-ctor true, :line 904, :record true, :end-line 904, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, if {:protocol-inline nil, :name schema.core/if, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 23, :method-params ([pred if-schema else-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag schema.core/ConditionalSchema, :variadic false, :max-fixed-arity 3}), :line 528, :end-line 528, :max-fixed-arity 3, :fn-var true, :arglists (quote ([pred if-schema else-schema])), :doc "if the predicate returns truthy, use the if-schema, otherwise use the else-schema", :test true}, Predicate {:num-fields 2, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/Predicate, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 35, :type true, :column 25, :internal-ctor true, :line 302, :record true, :end-line 302, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, make-fn-schema {:protocol-inline nil, :name schema.core/make-fn-schema, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 35, :method-params ([output-schema input-schemas]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag schema.core/FnSchema, :variadic false, :max-fixed-arity 2}), :line 923, :end-line 923, :max-fixed-arity 2, :fn-var true, :arglists (quote ([output-schema input-schemas])), :doc "A function outputting a value in output schema, whose argument vector must match one of\n   input-schemas, each of which should be a sequence schema.\n   Currently function schemas are purely descriptive; they validate against any function,\n   regardless of actual input and output types.", :test true}, map-walker {:protocol-inline nil, :private true, :name schema.core/map-walker, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 32, :method-params ([map-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 697, :end-line 697, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-schema])), :test true}, Str {:doc "Satisfied only by String.\n   Is (pred string?) and not js/String in cljs because of keywords.", :file "resources/public/js/compiled/out/schema/core.cljs", :line 376, :column 1, :end-line 376, :end-column 10, :test true, :name schema.core/Str}, map->EqSchema {:protocol-inline nil, :name schema.core/map->EqSchema, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 34, :method-params ([G__23624]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :methods ({:tag schema.core/EqSchema, :variadic false, :max-fixed-arity 1}), :line 248, :end-line 248, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__23624])), :test true}, ->AnythingSchema {:protocol-inline nil, :name schema.core/->AnythingSchema, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 40, :method-params ([_]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :methods ({:tag schema.core/AnythingSchema, :variadic false, :max-fixed-arity 1}), :line 234, :end-line 234, :max-fixed-arity 1, :fn-var true, :arglists (quote ([_])), :test true}, maybe {:protocol-inline nil, :name schema.core/maybe, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 26, :method-params ([schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag schema.core/Maybe, :variadic false, :max-fixed-arity 1}), :line 429, :end-line 429, :max-fixed-arity 1, :fn-var true, :arglists (quote ([schema])), :doc "A value that must either be nil or satisfy schema", :test true}, check {:protocol-inline nil, :name schema.core/check, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 26, :method-params ([schema x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 156, :end-line 156, :max-fixed-arity 2, :fn-var true, :arglists (quote ([schema x])), :doc "Return nil if x matches schema; otherwise, returns a value that looks like the\n   'bad' parts of x with ValidationErrors at the leaves describing the failures.", :test true}, pair {:protocol-inline nil, :name schema.core/pair, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 25, :method-params ([first-schema first-name second-schema second-name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 4}), :line 848, :end-line 848, :max-fixed-arity 4, :fn-var true, :arglists (quote ([first-schema first-name second-schema second-name])), :doc "A schema for a pair of schemas and their names", :test true}, set-fn-validation! {:protocol-inline nil, :name schema.core/set-fn-validation!, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 39, :method-params ([on?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 1019, :end-line 1019, :max-fixed-arity 1, :fn-var true, :arglists (quote ([on?])), :doc "Globally turn on schema validation for all s/fn and s/defn instances.", :test true}, EnumSchema {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/EnumSchema, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 36, :type true, :column 25, :internal-ctor true, :line 285, :record true, :end-line 285, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, ->OptionalKey {:protocol-inline nil, :name schema.core/->OptionalKey, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 37, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :methods ({:tag schema.core/OptionalKey, :variadic false, :max-fixed-arity 1}), :line 608, :end-line 608, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :test true}, ->ConditionalSchema {:protocol-inline nil, :name schema.core/->ConditionalSchema, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 43, :method-params ([preds-and-schemas]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :methods ({:tag schema.core/ConditionalSchema, :variadic false, :max-fixed-arity 1}), :line 501, :end-line 501, :max-fixed-arity 1, :fn-var true, :arglists (quote ([preds-and-schemas])), :test true}, ->NamedSchema {:protocol-inline nil, :name schema.core/->NamedSchema, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 37, :method-params ([schema name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :methods ({:tag schema.core/NamedSchema, :variadic false, :max-fixed-arity 2}), :line 437, :end-line 437, :max-fixed-arity 2, :fn-var true, :arglists (quote ([schema name])), :test true}, schematize-fn {:protocol-inline nil, :name schema.core/schematize-fn, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 34, :method-params ([f schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj cljs.core/MetaFn clj-nil}, :variadic false, :max-fixed-arity 2}), :line 1040, :end-line 1040, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f schema])), :doc "Attach the schema to fn f at runtime, extractable by fn-schema.", :test true}, Uuid {:doc "The local representation of #uuid ...", :file "resources/public/js/compiled/out/schema/core.cljs", :line 409, :column 1, :end-line 409, :end-column 11, :test true, :name schema.core/Uuid}, map->Isa {:protocol-inline nil, :name schema.core/map->Isa, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 29, :method-params ([G__23632]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :methods ({:tag schema.core/Isa, :variadic false, :max-fixed-arity 1}), :line 264, :end-line 264, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__23632])), :test true}, map->Either {:protocol-inline nil, :name schema.core/map->Either, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 32, :method-params ([G__23683]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :methods ({:tag schema.core/Either, :variadic false, :max-fixed-arity 1}), :line 452, :end-line 452, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__23683])), :test true}, ->Record {:protocol-inline nil, :name schema.core/->Record, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 32, :method-params ([klass schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :methods ({:tag schema.core/Record, :variadic false, :max-fixed-arity 2}), :line 862, :end-line 862, :max-fixed-arity 2, :fn-var true, :arglists (quote ([klass schema])), :test true}, protocol-name {:protocol-inline nil, :name schema.core/protocol-name, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 34, :method-params ([protocol]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 328, :end-line 328, :max-fixed-arity 1, :fn-var true, :arglists (quote ([protocol])), :test true}, Isa {:num-fields 2, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/Isa, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 29, :type true, :column 25, :internal-ctor true, :line 264, :record true, :end-line 264, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, +missing+ {:doc "A sentinel value representing missing portions of the input data.", :file "resources/public/js/compiled/out/schema/core.cljs", :line 591, :column 1, :end-line 591, :end-column 25, :no-doc true, :test true, :name schema.core/+missing+}, ->Either {:protocol-inline nil, :name schema.core/->Either, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 32, :method-params ([schemas]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :methods ({:tag schema.core/Either, :variadic false, :max-fixed-arity 1}), :line 452, :end-line 452, :max-fixed-arity 1, :fn-var true, :arglists (quote ([schemas])), :test true}, map->NamedSchema {:protocol-inline nil, :name schema.core/map->NamedSchema, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 37, :method-params ([G__23675]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :methods ({:tag schema.core/NamedSchema, :variadic false, :max-fixed-arity 1}), :line 437, :end-line 437, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__23675])), :test true}, start-walker {:protocol-inline nil, :name schema.core/start-walker, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 33, :method-params ([sub-walker schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 141, :end-line 141, :max-fixed-arity 2, :fn-var true, :arglists (quote ([sub-walker schema])), :doc "The entry point for creating walkers.  Binds the provided walker to subschema-walker,\n   then calls it on the provided schema.  For simple validation, pass walker as sub-walker.\n   More sophisticated behavior (coercion, etc), can be achieved by passing a sub-walker\n   that wraps walker with additional behavior.", :test true}, checker {:protocol-inline nil, :name schema.core/checker, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 28, :method-params ([schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 150, :end-line 150, :max-fixed-arity 1, :fn-var true, :arglists (quote ([schema])), :doc "Compile an efficient checker for schema, which returns nil for valid values and\n   error descriptions otherwise.", :test true}, Keyword {:doc "A keyword", :file "resources/public/js/compiled/out/schema/core.cljs", :line 393, :column 1, :end-line 393, :end-column 14, :test true, :name schema.core/Keyword}, ->MapEntry {:protocol-inline nil, :name schema.core/->MapEntry, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 34, :method-params ([kspec val-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :methods ({:tag schema.core/MapEntry, :variadic false, :max-fixed-arity 2}), :line 640, :end-line 640, :max-fixed-arity 2, :fn-var true, :arglists (quote ([kspec val-schema])), :test true}, ->Protocol {:protocol-inline nil, :name schema.core/->Protocol, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 34, :method-params ([p]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :methods ({:tag schema.core/Protocol, :variadic false, :max-fixed-arity 1}), :line 334, :end-line 334, :max-fixed-arity 1, :fn-var true, :arglists (quote ([p])), :test true}, ->Maybe {:protocol-inline nil, :name schema.core/->Maybe, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 31, :method-params ([schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :methods ({:tag schema.core/Maybe, :variadic false, :max-fixed-arity 1}), :line 420, :end-line 420, :max-fixed-arity 1, :fn-var true, :arglists (quote ([schema])), :test true}, explain-input-schema {:protocol-inline nil, :name schema.core/explain-input-schema, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 41, :method-params ([input-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 898, :end-line 898, :max-fixed-arity 1, :fn-var true, :arglists (quote ([input-schema])), :test true}, record {:protocol-inline nil, :name schema.core/record, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 27, :method-params ([klass schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag schema.core/Record, :variadic false, :max-fixed-arity 2}), :line 881, :end-line 881, :max-fixed-arity 2, :fn-var true, :arglists (quote ([klass schema])), :doc "A Record instance of type klass, whose elements match map schema 'schema'.", :test true}, optional-key? {:protocol-inline nil, :name schema.core/optional-key?, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 34, :method-params ([ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 615, :end-line 615, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ks])), :test true}, map->Both {:protocol-inline nil, :name schema.core/map->Both, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 30, :method-params ([G__23694]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :methods ({:tag schema.core/Both, :variadic false, :max-fixed-arity 1}), :line 476, :end-line 476, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__23694])), :test true}, required-key {:protocol-inline nil, :name schema.core/required-key, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 33, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil schema.core/RequiredKey}, :variadic false, :max-fixed-arity 1}), :line 597, :end-line 597, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k])), :doc "A required key in a map", :test true}, optional {:protocol-inline nil, :name schema.core/optional, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 29, :method-params ([schema name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag schema.core/One, :variadic false, :max-fixed-arity 2}), :line 784, :end-line 784, :max-fixed-arity 2, :fn-var true, :arglists (quote ([schema name])), :doc "A single optional element of a sequence (not repeated, the implicit default)", :test true}, Int {:doc "Any integral number", :file "resources/public/js/compiled/out/schema/core.cljs", :line 389, :column 1, :end-line 389, :end-column 10, :test true, :name schema.core/Int}, ->FnSchema {:protocol-inline nil, :name schema.core/->FnSchema, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 34, :method-params ([output-schema input-schemas]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :methods ({:tag schema.core/FnSchema, :variadic false, :max-fixed-arity 2}), :line 904, :end-line 904, :max-fixed-arity 2, :fn-var true, :arglists (quote ([output-schema input-schemas])), :test true}, Schema {:protocol-symbol true, :name schema.core/Schema, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 21, :column 1, :line 95, :protocol-info {:methods {walker [[this]], explain [[this]]}}, :info nil, :end-line 95, :impls #{schema.core/Isa cljs/core.PersistentHashMap js/RegExp cljs/core.PersistentArrayMap schema.core/NamedSchema cljs/core.PersistentVector schema.core/Either schema.core/Both cljs/core.PersistentHashSet schema.core/ConditionalSchema schema.core/Record schema.core/EqSchema schema.core/MapEntry function schema.core/Maybe schema.core/AnythingSchema schema.core/FnSchema schema.core/Predicate schema.core/EnumSchema schema.core/Protocol}, :test true}, Both {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection schema.core/Schema cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.core/Both, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 30, :type true, :column 25, :internal-ctor true, :line 476, :record true, :end-line 476, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, map->Maybe {:protocol-inline nil, :name schema.core/map->Maybe, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 31, :method-params ([G__23667]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :methods ({:tag schema.core/Maybe, :variadic false, :max-fixed-arity 1}), :line 420, :end-line 420, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__23667])), :test true}, map-entry {:protocol-inline nil, :name schema.core/map-entry, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 30, :method-params ([kspec val-schema]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag schema.core/MapEntry, :variadic false, :max-fixed-arity 2}), :line 679, :end-line 679, :max-fixed-arity 2, :fn-var true, :arglists (quote ([kspec val-schema])), :test true}, walker {:protocol-inline nil, :protocol schema.core/Schema, :name schema.core/walker, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 11, :method-params ([this]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 95, :end-line 96, :max-fixed-arity 1, :fn-var true, :arglists (quote ([this])), :test true}, specific-key? {:protocol-inline nil, :name schema.core/specific-key?, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 34, :method-params ([ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag boolean, :variadic false, :max-fixed-arity 1}), :line 625, :end-line 625, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ks])), :test true}, map->EnumSchema {:protocol-inline nil, :name schema.core/map->EnumSchema, :variadic false, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 36, :method-params ([G__23640]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :methods ({:tag schema.core/EnumSchema, :variadic false, :max-fixed-arity 1}), :line 285, :end-line 285, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__23640])), :test true}, both {:protocol-inline nil, :name schema.core/both, :variadic true, :file "resources/public/js/compiled/out/schema/core.cljs", :end-column 25, :method-params ([schemas]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag schema.core/Both, :variadic true, :max-fixed-arity 0}), :line 493, :end-line 493, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& schemas])), :doc "A value that must satisfy every schema in schemas.", :test true}}, :name schema.core, :doc "A library for data shape definition and validation. A Schema is just Clojure data,\n   which can be used to document and validate Clojure functions and data.\n\n   For example,\n\n   (def FooBar {:foo Keyword :bar [Number]}) ;; a schema\n\n   (check FooBar {:foo :k :bar [1.0 2.0 3.0]})\n   ==> nil\n\n   representing successful validation, but the following all return helpful errors\n   describing how the provided data fails to measure up to schema FooBar's standards.\n\n   (check FooBar {:bar [1.0 2.0 3.0]})\n   ==> {:foo missing-required-key}\n\n   (check FooBar {:foo 1 :bar [1.0 2.0 3.0]})\n   ==> {:foo (not (keyword? 1))}\n\n   (check FooBar {:foo :k :bar [1.0 2.0 3.0] :baz 1})\n   ==> {:baz disallowed-key}\n\n   Schema lets you describe your leaf values using the Any, Keyword, Symbol, Number,\n   String, and Int definitions below, or (in Clojure) you can use arbitrary Java\n   classes or primitive casts to describe simple values.\n\n   From there, you can build up schemas for complex types using Clojure syntax\n   (map literals for maps, set literals for sets, vector literals for sequences,\n   with details described below), plus helpers below that provide optional values,\n   enumerations, arbitrary predicates, and more.\n\n   Assuming you (:require [schema.core :as s :include-macros true]),\n   Schema also provides macros for defining records with schematized elements\n   (s/defrecord), and named or anonymous functions (s/fn and s/defn) with\n   schematized inputs and return values.  In addition to producing better-documented\n   records and functions, these macros allow you to retrieve the schema associated\n   with the defined record or function.  Moreover, functions include optional\n   *validation*, which will throw an error if the inputs or outputs do not\n   match the provided schemas:\n\n   (s/defrecord FooBar\n    [foo :- Int\n     bar :- String])\n\n   (s/defn quux :- Int\n    [foobar :- Foobar\n     mogrifier :- Number]\n    (* mogrifier (+ (:foo foobar) (Long/parseLong (:bar foobar)))))\n\n   (quux (FooBar. 10 \"5\") 2)\n   ==> 30\n\n   (fn-schema quux)\n   ==> (=> Int (record user.FooBar {:foo Int, :bar java.lang.String}) java.lang.Number)\n\n   (s/with-fn-validation (quux (FooBar. 10.2 \"5\") 2))\n   ==> Input to quux does not match schema: [(named {:foo (not (integer? 10.2))} foobar) nil]\n\n   As you can see, the preferred syntax for providing type hints to schema's defrecord,\n   fn, and defn macros is to follow each element, argument, or function name with a\n   :- schema.  Symbols without schemas default to a schema of Any.  In Clojure,\n   class (e.g., clojure.lang.String) and primitive schemas (long, double) are also\n   propagated to tag metadata to ensure you get the type hinting and primitive\n   behavior you ask for.\n\n   If you don't like this style, standard Clojure-style typehints are also supported:\n\n   (fn-schema (s/fn [^String x]))\n   ==> (=> Any java.lang.String)\n\n   **DEPRECATED SYNTAX BELOW, TO BE REMOVED**\n   You can directly type hint a symbol as a class, primitive, protocol, or simple\n   schema.  For complex schemas, due to Clojure's rules about ^, you must enclose\n   the schema in a {:s schema} map like so:\n\n   (fn-schema (s/fn [^{:s [String]} x]))\n   (=> Any [java.lang.String])\n\n   (We highly prefer the :- syntax to this abomination, however.)  See the docstrings\n   of defrecord, fn, and defn for more details about how to use these macros.", :excludes #{Symbol defn defmethod letfn Keyword defrecord}, :use-macros nil, :require-macros {schema.macros schema.macros, macros schema.macros}, :uses nil, :requires {utils schema.utils, schema.utils schema.utils, clojure.string clojure.string, str clojure.string}, :imports nil}